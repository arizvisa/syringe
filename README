hooker
    * collection of tools intended for manipulating control flow
    - hooking an arbitrary address
        * patching in a farjmp, lifting the code, blah blah
            * this will need to be tested out as i've failed to do this via .dvalloc
                in a generic fashion, but i might suck at managing my thoughts in a debugger
    - hooking exports (for all modules)
    - hooking imports for a particular module
    - hooking heap locks
    - hooking peb lock
    - hooking exceptions
    - hooking module load/unload
    - hooking thread load/unload

disasm:
    X rewrite ia32.decode using new length disassembler
        X import oplength table into python
    - write tests for new implementation of ia32.decode32 (?)
    - replace generate-table.pl with something better

asm:
    * optional
    * cody wants this
    - will need some way of emitting instructions
        - perhaps also emitting llvm

loader:
    - inject the following functionality
        - the python interpreter .dll
        - the python hook stub
        - perhaps tools for allocating executable memory
            X like the memqueue and page specific code
                * ensure this is relocateable
            X perhaps the lde code too
                * we can hook ourself now

    X injection
        X memorymanager.alloc some space
        X writeprocessmem python code
        X setthreadcontext address of virtual alloc

    - first stub for injection
        * i'll need to double-check how much this will tamper with it
        - finds out main gui thread
        - queue rest of our code to gui thread (queueuserapcdispatch i think)

        - look to see if python already exists in the process
            - if it exists, then return it's address
        - wait for the loader lock
        - suspend all threads but ours
        - load the python dll
            * need to ensure python uses a different heap just in case

-> work/pCOFF.py
    X provide a dictionary to resolve symbols
    - output some page of contiguous memory which contains all relocations and all that shit
    - support linking of multiple object files

-> work/alloc.py
    X memory allocator (page granularity)
    X   allocate_memory
    X       return a pointer to some writeable memory
    X   lock_memory
    X       make that pointer executable, but unwriteable. this will actually
    X       return a pointer to the address that is executable
    X   unlock_memory
    X       will unexecute the memory
    X   free_memory
    X       deallocate the memory
            
-> work/inject.py
    - figure out how to provide an interface from the debugger to 
      some of the injected functionality
        - python interpreter
        - hook
        - memqueue construction
        - initial memory allocations
            * the memqueue could possibly be stored in Tls or some page
              somewhere

-> work/debug.py
debugger api
    x finished implementing attach,detach,read,write
        * need to have context associated with it

    * figure out why the following logic doesn't work in windows:

        suspendthread(thread)
        setthreadcontext( thread, {eip=wherever, eax=whatever} )
        resumethread(thread)

        something seems to mangle our context state (%eax, and stuff other than
        %eip) before we actually execute our specified eip. i suspect it's
        dispatched for window messages by the kernel.


-> src/python-stub.s
python stub
    - clean up this code in order to be remotely injectable (??)
    - merge with injector utils code

-> ??
injector utilities
    X add functions for doing heap management
    - implement dynamic symbol resolver for providing to python (maybe)
    - come up with more things that might be useful
      (like an instruction granularity profiler (to be less intrusive) )

-> ??
python utils
    - check to see if we can use ctypes for all of this
    
    - write code for calling native code for python
        - cdecl
        - stdcall
        - fastcall
        - thiscall
        - syscall

-> work/ctypesless.py
making ctypes allow non-typesafe stuff
    - implement way for converting to and back from the
      different ctype structures, essentially we want a
      native python data structure that doesn't do type checking
      because we want to be able to shoot ourselves in the foot

results (or the problems this aims to solve)
    we can arbitrarily instrument any part of the process
    we can reuse any code inside the process
        - that way we can test out what we think a function will do
    we can describe data structures that we have inside the process
        - like ptypes, but i think it should be redesigned with "casting"
          structures to memory spaces, instead of reading a stream of input
            * the reason why i don't want to use ptypes is because
              if we treat the .offset property of a ptype as an address, then
              the only way i can think of is to lower the iterator that's used
              to deserialize from a memory address. this then creates another copy
              of the data in python, when python can just use that address (i hope)

