hooker:
    * collection of tools intended for manipulating control flow
    - patching in a farjmp, lifting the code, blah blah
    - hooking exports

disasm:
    - rewrite ia32.decode using new length disassembler
        - import oplength table into python

asm:
    * optional
    - will need some way of emitting instructions
        - perhaps also emitting llvm

loader:
    - inject the following functionality
        - the python interpreter .dll
        - the python hook stub
        - perhaps tools for allocating executable memory
            X like the memqueue and page specific code
                * ensure this is relocateable
            X perhaps the lde code too
                * we can hook ourself now

    - injection
        - virtual alloc some space
        - writeprocessmem python code
        - setthreadcontext address of virtual alloc

    - first stub for injection
        * i'll need to double-check how much this will tamper with it
        - finds out main gui thread
        - queue rest of our code to gui thread (queueuserapcdispatch i think)

        - look to see if python already exists in the process
            - if it exists, then return it's address
        - wait for the loader lock
        - suspend all threads but ours
        - load the python dll
            * need to ensure python uses a different heap just in case

    X memory allocator (page granularity)
    X   allocate_memory
    X       return a pointer to some writeable memory
    X   lock_memory
    X       make that pointer executable, but unwriteable. this will actually
    X       return a pointer to the address that is executable
    X   unlock_memory
    X       will unexecute the memory
    X   free_memory
    X       deallocate the memory
            
    - figure out how to provide an interface from the debugger to 
      some of the injected functionality
        - python interpreter
        - hook
        - memqueue construction
        - initial memory allocations
            * the memqueue could possibly be stored in Tls or some page
              somewhere

debugger api
    - figure out why the following logic doesn't work:

        suspendthread(thread)
        setthreadcontext( thread, {eip=wherever, eax=whatever} )
        resumethread(thread)

        something seems to mangle our context state (%eax, and stuff other than
        %eip) before we actually execute our specified eip. i suspect it's
        dispatched for window messages by the kernel.

    - finished implementing attach,detach,read,write
        * need to have context associated with it

python stub
    - clean up this code in order to be remotely injectable
    - merge with injector utils code

injector utilities
    - add functions for doing heap management
    - implement dynamic symbol resolver for providing to python (maybe)
    - come up with more things that might be useful
      (like an instruction granularity profiler (to be less intrusive) )

python utils
    - check to see if we can use ctypes for all of this
    
    - write code for calling native code for python
        - cdecl
        - stdcall
        - fastcall
        - thiscall
        - syscall

    - ctypesless
        - implement way for converting to and back from the
          different ctype structures, essentially we want a
          native python data structure that doesn't do type checking
          because we want to shoot ourselves in the foot

results (or the problems this aims to solve)
    we can arbitrarily instrument any part of the process
    we can reuse any code inside the process
        - that way we can test out what we think a function will do
    we can describe data structures that we have inside the process
        - like ptypes, but i think it should be redesigned with "casting"
          structures to memory spaces, instead of reading a stream of input
            * the reason why i don't want to use ptypes is because
              if we treat the .offset property of a ptype as an address, then
              the only way i can think of is to lower the iterator that's used
              to deserialize from a memory address. this then creates another copy
              of the data in python, when python can just use that address (i hope)

